#!/usr/bin/env python3

# COPYRIGHT #
#
# Copyright 2018, Teodor George Oprea, All rights reserved.
# I am not responsible for your actions.
#
# COPYRIGHT #

version = "1.0.0-beta"
author = "1Intuition"

import argparse
from ast import literal_eval
import itertools
import sys
import string
from pathlib import Path


def generate(a, to, from_var=None):
    if from_var is None:
        print("\nCreating iterator...")
        gen_iter = itertools.product(*a)
        print("\nJoining iterator and writing to file...")
        with open(to, 'w') as file:
            for x in gen_iter:
                n = ''.join(map(str, x))
                file.write(n)
                file.write("\n")
    else:
        print("\nCreating iterator...")
        gen_iter = itertools.product(*a)
        print("\nJoining iterator and writing to file...")
        with open(to, 'w') as file:
            passed = False
            for x in gen_iter:
                n = ''.join(map(str, x))
                if from_var == n:
                    passed = True
                else:
                    if passed:
                        file.write(n)
                        file.write("\n")
                    else:
                        continue


def stdout_generate(a, from_var=None):
    if from_var is None:
        gen_iter = itertools.product(*a)
        for x in gen_iter:
            n = ''.join(map(str, x))
            print(n)
        exit()
    else:
        gen_iter = itertools.product(*a)
        passed = False
        for x in gen_iter:
            n = ''.join(map(str, x))
            if from_var == n:
                passed = True
            else:
                if passed:
                    print(n)
                else:
                    continue


def check_for_luns(n):
    if "--l" in n:
        # all lowercase letters
        n = n.replace("--l", string.ascii_lowercase)
    if "--u" in n:
        # all uppercase letters
        n = n.replace("--u", string.ascii_uppercase)
    if "--n" in n:
        # all numbers
        n = n.replace("--n", string.digits)
    if "--s" in n:
        # all symbols
        n = n.replace("--s", """ !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'""")
    return n


def clear_screen_with_returns():
    v = 0
    while v < 25:
        print("\n")
        v += 1


def query_yes_no(question, default=None):
    """Ask a yes/no question via raw_input() and return their answer.
    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).
    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)
    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


def size_format(number_of_bytes):
    if number_of_bytes < 0:
        raise ValueError("!!! number_of_bytes can't be smaller than 0 !!!")
    step_to_greater_unit = 1024.
    number_of_bytes = float(number_of_bytes)
    unit = 'bytes'
    if (number_of_bytes / step_to_greater_unit) >= 1:
        number_of_bytes /= step_to_greater_unit
        unit = 'KB'
    if (number_of_bytes / step_to_greater_unit) >= 1:
        number_of_bytes /= step_to_greater_unit
        unit = 'MB'
    if (number_of_bytes / step_to_greater_unit) >= 1:
        number_of_bytes /= step_to_greater_unit
        unit = 'GB'
    if (number_of_bytes / step_to_greater_unit) >= 1:
        number_of_bytes /= step_to_greater_unit
        unit = 'TB'
    precision = 1
    number_of_bytes = round(number_of_bytes, precision)
    return str(number_of_bytes) + ' ' + unit


def main():
    parser = argparse.ArgumentParser(
        prog='gpchar',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage="\n--- 3 MODES ---"
              "\n./gpchar --guided       (generate custom wordlist)"
              "\n./gpchar -c chars       (generate custom wordlist)"
              "\n./gpchar -i full_path   (generate wordlist with a config file)",
        description=None,
        epilog="GPCHAR is a python program that allows you to generate wordlists. "
               "However,\nit is a different than the other word list generators because "
               "you can choose\nwhat characters can be allowed in each position of the output words."
               "\n\nA small example will be is you know that the first position is an 'a' and the\n"
               "second can be '1', '2', or '3', then it will generate 'a1','a2', and 'a3'."
               "\n\nTo make it easier, when you type the possible characters, you can also type:\n"
               "    --l  : all lowercase letters    abcdefghijklmnopqrstuvwxyz\n"
               "    --u  : all uppercase letters    ABCDEFGHIJKLMNOPQRSTUVWXYZ\n"
               "    --n  : all uppercase letters    0123456789\n"
               """    --s  : all symbols              !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'\n"""
               "\nYou can combine them with some other characters, for example:\n"
               "    abc--u--n       -->     abcABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
    parser.add_argument("-v", "--version", help="shows version and exits", action="store_true")
    parser.add_argument("--guided", help="helps you create", action="store_true")
    parser.add_argument("--stdout", help="stdout", action="store_true")
    parser.add_argument("--override", help="used with -o arg to override file", action="store_true")
    parser.add_argument("-i", help="Import config file", metavar="full_path", type=str)
    parser.add_argument("-o", help="Output file", metavar="full_path", type=str)
    parser.add_argument("-c", help="chars", metavar="chars", type=str)
    parser.add_argument("-f", help="Output config", metavar="full_path", type=str)
    parser.add_argument("-s", help="sure_char", metavar="sure_char", type=str)
    parser.add_argument("--after", help="Generate after this word", metavar="word", type=str)
    args = parser.parse_args()

    # print("args.guided:\n{}\nsys.argv\n{}\n".format(args.guided, sys.argv))
    # exit()

    # show version
    if args.version:
        print("GPCHAR v{}".format(version))
        exit()

    # error if
    if args.s:
        print("ERROR: Sure char not yet functional")
        exit()

    if args.guided and sys.argv != ['gpchar', '--guided'] and sys.argv != ['./gpchar', '--guided']:
        print("ERROR: The --guided argument can only be used alone!")
        exit()
    if args.o and args.stdout:
        print("ERROR: Cannot use -o and --stdout args together")
        exit()
    if args.override and not args.o:
        print("ERROR: Cannot use --override arg without -o arg")
        exit()
    if args.f and args.i:
        print("ERROR: Cannot use -i and -f args together")
        exit()
    if args.i and args.c:
        print("ERROR: Cannot use -i and -c args together")
        exit()
    if args.c and not args.stdout and not args.o and not args.f:
        print("ERROR: Too few args used with -c arg")
        exit()

    # if chars arg
    if args.c or args.i:
        if args.c:  # CHAR ARGS
            list1 = args.c.split("//")
            array = list()
            for x in list1:
                n = check_for_luns(x)
                u = list(sorted(set(n)))
                if u:
                    array.append(u)

            # set sure_char
            if args.s:
                sure_char = args.s
            else:
                sure_char = ""

            # set config path
            if args.f:
                try:
                    output_path = args.f
                    with open(output_path, 'w') as file:
                        file.write(sure_char)
                        for i in array:
                            file.write("\n")
                            file.write(str(i))
                except IOError:
                    print("ERROR: Writing file failed!\n")
                    exit()

        elif args.i:

            with open(args.i) as f:
                array = f.read().splitlines()
            sure_char = array[0]  # set sure_char
            del array[0]
            array1 = []
            for e in array:
                n = literal_eval(e)
                array1.append(n)
            array = array1  # set array

        if sure_char == "":
            if args.stdout:
                stdout_generate(array, args.after)
                exit()

            elif args.o:
                if Path(args.o).is_file():
                    if args.override:
                        generate(array, args.o, args.after)
                    else:
                        print("ERROR: File exists! Use --override argument.")
                        exit()
                else:
                    try:
                        generate(array, args.o, args.after)
                    except:
                        print("ERROR: File cannot be created! Please verify the path.")
                        exit()

        else:
            print("Surechar not ready yet!!!")
            exit()

        exit()

    elif args.guided:
        # prog info
        clear_screen_with_returns()
        print("GeneratorPerCharacter\n"
              "AKA: GPChar\n"
              "\nBy {}\n\n".format(author))

        # ask if config file
        if query_yes_no("\nDo you want to generate the wordlist from a config file?"):
            while True:
                config_input_path = input("Enter the path to the config file:\n")

                if config_input_path == "":
                    print("ERROR: It cannot be empty!\n")
                    continue
                else:
                    # path without quotes
                    if Path(config_input_path).is_file():
                        with open(config_input_path) as f:
                            array = f.read().splitlines()
                        sure_char = array[0]  # set sure_char
                        del array[0]
                        array1 = []
                        for e in array:
                            n = literal_eval(e)
                            array1.append(n)
                        array = array1  # set array
                        break

                    # path with quotes
                    elif Path(eval(config_input_path)).is_file():
                        config_input_path = eval(config_input_path)
                        with open(config_input_path) as f:
                            array = f.read().splitlines()
                        sure_char = array[0]  # set sure_char
                        del array[0]
                        array1 = []
                        for e in array:
                            n = literal_eval(e)
                            array1.append(n)
                        array = array1  # set array
                        break

                    # file not exist
                    else:
                        print("ERROR: File does not exist!")
                        continue

        # if not config gen -> create array
        else:
            print("Then, let's generate without!\n")
            # specifies the lentgh
            array = list()
            try:
                char = int(input("Length: "))
            except:
                print("ERROR: It must be an integer!\n")
                exit()
            if char > 25:
                print("ERROR: Cannot be more than 25 characters!\n")
                exit()

            # sets each value in list array
            for i in range(char):
                while True:
                    n = input("Character {}: ".format(i+1))
                    if n != "":
                        break
                    elif n == "":
                        print("ERROR: It cannot be empty!\n")
                    else:
                        print("UNEXPECTED ERROR\n")
                n = check_for_luns(n)
                u = list(sorted(set(n)))
                array.append(u)

            # set surechar
            sure_char = input("\nAny letter(s) you are sure: ex. m,q [leave blank if none]\n")

            # set config path
            while True:
                try:
                    output_path = input("\nExport config file to this full path: [Leave blank if you don't want]\n")
                    if output_path != "":
                        with open(output_path, 'w') as file:
                            file.write(sure_char)
                            for i in array:
                                file.write("\n")
                                file.write(str(i))
                        print("\nConfig file exported to {}".format(output_path))
                        break
                    else:
                        break
                except IOError:
                    print("ERROR: Writing file failed!\n")

    else:
        parser.print_help()
        exit()

    # IF NO SURECHAR
    if sure_char == "":

        # display info of the gen
        array1 = list(map(''.join, array))
        length_each = []
        for i in array1:
            n = len(i)
            length_each.append(n)
        no_words = 1
        for i in length_each:
            no_words *= i
        # print "Length of each object in array1:",length_each
        print("\nNumber of words:", no_words)
        print("Length of words: ", len(array1))
        no_bytes = size_format(no_words * (len(array1) + 1))
        print("Number of bytes:", no_bytes, "(approximately)\n")

        # if stdout or not
        if query_yes_no("Do you want to generate as a STDOUT?\n"
                        "(print it instead of writing it on to a file)", "no"):

            stdout_generate(array)
            exit()

        # ask is gen or not.
        elif query_yes_no("Do you want to generate the wordlist?"):
            while True:
                gen_path = input("\nExport wordlist to this full path or relative path:\n")
                if gen_path == "":
                    print("ERROR: Enter a full path or a relative path!")
                    continue

                else:
                    if Path(gen_path).is_file():
                        override_question = "Do you want to overwrite the file {} ?".format(gen_path)
                        if query_yes_no(str(override_question)):
                            generate(array, gen_path)
                            break
                        else:
                            continue
                    else:
                        try:
                            generate(array, gen_path)
                            break
                        except IOError:
                            print("ERROR: File cannot be created! Please verify the path.")

            print("Thank you for using GPCHAR!")
            exit()

        else:
            exit()

    # IF SURECHAR:
    else:
        print("\nYou cannot use the SURECHAR option at the moment."
              "\nSorry for the inconvenience.")
        # sure_char = sure_char.split(',') # sure_chars split
        # say how much bytes
        # run gen
        exit()
    # write on file


if __name__ == '__main__':
    main()